// 算法来自 https://github.com/shibing624/pinyin-tokenizer

use litemap::LiteMap;
use std::sync::LazyLock;

pub(crate) static PINYIN_TRIE: LazyLock<TrieNode> = LazyLock::new(|| {
    let mut trie = TrieNode::new("", &[]);
    let pinyin_list = vec![
        &["a"],
        &["ai"],
        &["an"],
        &["ang"],
        &["ao"],
        &["e"],
        &["ei"],
        &["en"],
        &["er"],
        &["o"],
        &["ou"],
    ];
    for pinyin in pinyin_list {
        trie.add(pinyin);
    }
    let pinyin_list = vec![
        &["b", "a"],
        &["b", "ai"],
        &["b", "an"],
        &["b", "ang"],
        &["b", "ao"],
        &["b", "ei"],
        &["b", "en"],
        &["b", "eng"],
        &["b", "i"],
        &["b", "ian"],
        &["b", "iao"],
        &["b", "ie"],
        &["b", "in"],
        &["b", "ing"],
        &["b", "o"],
        &["b", "u"],
        &["c", "a"],
        &["c", "ai"],
        &["c", "an"],
        &["c", "ang"],
        &["c", "ao"],
        &["c", "e"],
        &["c", "en"],
        &["c", "eng"],
        &["c", "i"],
        &["c", "ong"],
        &["c", "ou"],
        &["c", "u"],
        &["c", "uan"],
        &["c", "ui"],
        &["c", "un"],
        &["c", "uo"],
        &["ch", "a"],
        &["ch", "ai"],
        &["ch", "an"],
        &["ch", "ang"],
        &["ch", "ao"],
        &["ch", "e"],
        &["ch", "en"],
        &["ch", "eng"],
        &["ch", "i"],
        &["ch", "ong"],
        &["ch", "ou"],
        &["ch", "u"],
        &["ch", "uai"],
        &["ch", "uan"],
        &["ch", "uang"],
        &["ch", "ui"],
        &["ch", "un"],
        &["ch", "uo"],
        &["d", "a"],
        &["d", "ai"],
        &["d", "an"],
        &["d", "ang"],
        &["d", "ao"],
        &["d", "e"],
        &["d", "eng"],
        &["d", "i"],
        &["d", "ia"],
        &["d", "ian"],
        &["d", "iao"],
        &["d", "ie"],
        &["d", "ing"],
        &["d", "iu"],
        &["d", "ong"],
        &["d", "ou"],
        &["d", "u"],
        &["d", "uan"],
        &["d", "ui"],
        &["d", "un"],
        &["d", "uo"],
        &["f", "a"],
        &["f", "an"],
        &["f", "ang"],
        &["f", "ei"],
        &["f", "en"],
        &["f", "eng"],
        &["f", "o"],
        &["f", "ou"],
        &["f", "u"],
        &["g", "a"],
        &["g", "ai"],
        &["g", "an"],
        &["g", "ang"],
        &["g", "ao"],
        &["g", "e"],
        &["g", "ei"],
        &["g", "en"],
        &["g", "eng"],
        &["g", "ong"],
        &["g", "ou"],
        &["g", "u"],
        &["g", "ua"],
        &["g", "uai"],
        &["g", "uan"],
        &["g", "uang"],
        &["g", "ui"],
        &["g", "un"],
        &["g", "uo"],
        &["h", "a"],
        &["h", "ai"],
        &["h", "an"],
        &["h", "ang"],
        &["h", "ao"],
        &["h", "e"],
        &["h", "ei"],
        &["h", "en"],
        &["h", "eng"],
        &["h", "ong"],
        &["h", "ou"],
        &["h", "u"],
        &["h", "ua"],
        &["h", "uai"],
        &["h", "uan"],
        &["h", "uang"],
        &["h", "ui"],
        &["h", "un"],
        &["h", "uo"],
        &["j", "i"],
        &["j", "ia"],
        &["j", "ian"],
        &["j", "iang"],
        &["j", "iao"],
        &["j", "ie"],
        &["j", "in"],
        &["j", "ing"],
        &["j", "iong"],
        &["j", "iu"],
        &["j", "u"],
        &["j", "uan"],
        &["j", "ue"],
        &["j", "un"],
        &["k", "a"],
        &["k", "ai"],
        &["k", "an"],
        &["k", "ang"],
        &["k", "ao"],
        &["k", "e"],
        &["k", "en"],
        &["k", "eng"],
        &["k", "ong"],
        &["k", "ou"],
        &["k", "u"],
        &["k", "ua"],
        &["k", "uai"],
        &["k", "uan"],
        &["k", "uang"],
        &["k", "ui"],
        &["k", "un"],
        &["k", "uo"],
        &["l", "a"],
        &["l", "ai"],
        &["l", "an"],
        &["l", "ang"],
        &["l", "ao"],
        &["l", "e"],
        &["l", "ei"],
        &["l", "eng"],
        &["l", "i"],
        &["l", "ia"],
        &["l", "ian"],
        &["l", "iang"],
        &["l", "iao"],
        &["l", "ie"],
        &["l", "in"],
        &["l", "ing"],
        &["l", "iu"],
        &["l", "ong"],
        &["l", "ou"],
        &["l", "u"],
        &["l", "u:"],
        &["l", "v"],
        &["l", "ue"],
        &["l", "ve"],
        &["l", "uan"],
        &["l", "un"],
        &["l", "uo"],
        &["m", ""],
        &["m", "a"],
        &["m", "ai"],
        &["m", "an"],
        &["m", "ang"],
        &["m", "ao"],
        &["m", "e"],
        &["m", "ei"],
        &["m", "en"],
        &["m", "eng"],
        &["m", "i"],
        &["m", "ian"],
        &["m", "iao"],
        &["m", "ie"],
        &["m", "in"],
        &["m", "ing"],
        &["m", "iu"],
        &["m", "o"],
        &["m", "ou"],
        &["m", "u"],
        &["n", "a"],
        &["n", "ai"],
        &["n", "an"],
        &["n", "ang"],
        &["n", "ao"],
        &["n", "e"],
        &["n", "ei"],
        &["n", "en"],
        &["n", "eng"],
        &["n", "g"],
        &["n", "i"],
        &["n", "ian"],
        &["n", "iang"],
        &["n", "iao"],
        &["n", "ie"],
        &["n", "in"],
        &["n", "ing"],
        &["n", "iu"],
        &["n", "ong"],
        &["n", "ou"],
        &["n", "u"],
        &["n", "u:"],
        &["n", "ue"],
        &["n", "v"],
        &["n", "ve"],
        &["n", "uan"],
        &["n", "uo"],
        &["p", "a"],
        &["p", "ai"],
        &["p", "an"],
        &["p", "ang"],
        &["p", "ao"],
        &["p", "ei"],
        &["p", "en"],
        &["p", "eng"],
        &["p", "i"],
        &["p", "ian"],
        &["p", "iao"],
        &["p", "ie"],
        &["p", "in"],
        &["p", "ing"],
        &["p", "o"],
        &["p", "ou"],
        &["p", "u"],
        &["q", "i"],
        &["q", "ia"],
        &["q", "ian"],
        &["q", "iang"],
        &["q", "iao"],
        &["q", "ie"],
        &["q", "in"],
        &["q", "ing"],
        &["q", "iong"],
        &["q", "iu"],
        &["q", "u"],
        &["q", "uan"],
        &["q", "ue"],
        &["q", "un"],
        &["r", "an"],
        &["r", "ang"],
        &["r", "ao"],
        &["r", "e"],
        &["r", "en"],
        &["r", "eng"],
        &["r", "i"],
        &["r", "ong"],
        &["r", "ou"],
        &["r", "u"],
        &["r", "uan"],
        &["r", "ui"],
        &["r", "un"],
        &["r", "uo"],
        &["s", "a"],
        &["s", "ai"],
        &["s", "an"],
        &["s", "ang"],
        &["s", "ao"],
        &["s", "e"],
        &["s", "en"],
        &["s", "eng"],
        &["s", "i"],
        &["s", "ong"],
        &["s", "ou"],
        &["s", "u"],
        &["s", "uan"],
        &["s", "ui"],
        &["s", "un"],
        &["s", "uo"],
        &["sh", "a"],
        &["sh", "ai"],
        &["sh", "an"],
        &["sh", "ang"],
        &["sh", "ao"],
        &["sh", "e"],
        &["sh", "ei"],
        &["sh", "en"],
        &["sh", "eng"],
        &["sh", "i"],
        &["sh", "ou"],
        &["sh", "u"],
        &["sh", "ua"],
        &["sh", "uai"],
        &["sh", "uan"],
        &["sh", "uang"],
        &["sh", "ui"],
        &["sh", "un"],
        &["sh", "uo"],
        &["t", "a"],
        &["t", "ai"],
        &["t", "an"],
        &["t", "ang"],
        &["t", "ao"],
        &["t", "e"],
        &["t", "eng"],
        &["t", "i"],
        &["t", "ian"],
        &["t", "iao"],
        &["t", "ie"],
        &["t", "ing"],
        &["t", "ong"],
        &["t", "ou"],
        &["t", "u"],
        &["t", "uan"],
        &["t", "ui"],
        &["t", "un"],
        &["t", "uo"],
        &["w", "a"],
        &["w", "ai"],
        &["w", "an"],
        &["w", "ang"],
        &["w", "ei"],
        &["w", "en"],
        &["w", "eng"],
        &["w", "o"],
        &["w", "u"],
        &["x", "i"],
        &["x", "ia"],
        &["x", "ian"],
        &["x", "iang"],
        &["x", "iao"],
        &["x", "ie"],
        &["x", "in"],
        &["x", "ing"],
        &["x", "iong"],
        &["x", "iu"],
        &["x", "u"],
        &["x", "uan"],
        &["x", "ue"],
        &["x", "un"],
        &["y", "a"],
        &["y", "an"],
        &["y", "ang"],
        &["y", "ao"],
        &["y", "e"],
        &["y", "i"],
        &["y", "iao"],
        &["y", "in"],
        &["y", "ing"],
        &["y", "o"],
        &["y", "ong"],
        &["y", "ou"],
        &["y", "u"],
        &["y", "uan"],
        &["y", "ue"],
        &["y", "un"],
        &["z", "a"],
        &["z", "ai"],
        &["z", "an"],
        &["z", "ang"],
        &["z", "ao"],
        &["z", "e"],
        &["z", "ei"],
        &["z", "en"],
        &["z", "eng"],
        &["z", "i"],
        &["z", "ong"],
        &["z", "ou"],
        &["z", "u"],
        &["z", "uan"],
        &["z", "ui"],
        &["z", "un"],
        &["z", "uo"],
        &["zh", "a"],
        &["zh", "ai"],
        &["zh", "an"],
        &["zh", "ang"],
        &["zh", "ao"],
        &["zh", "e"],
        &["zh", "en"],
        &["zh", "eng"],
        &["zh", "i"],
        &["zh", "ong"],
        &["zh", "ou"],
        &["zh", "u"],
        &["zh", "ua"],
        &["zh", "uai"],
        &["zh", "uan"],
        &["zh", "uang"],
        &["zh", "ui"],
        &["zh", "un"],
        &["zh", "uo"],
    ];
    for pinyin in pinyin_list {
        trie.add(pinyin);
    }
    trie
});

#[derive(Debug)]
#[allow(unused)]
pub(crate) struct TrieNode<'a> {
    key: &'a str,
    is_end: bool,
    children: LiteMap<&'a str, TrieNode<'a>>,
}

impl<'a> TrieNode<'a> {
    fn new(key: &'a str, seq: &[&'a str]) -> Self {
        let mut node = TrieNode {
            key,
            is_end: seq.is_empty(),
            children: LiteMap::new(),
        };
        if !seq.is_empty() {
            let (first, rest) = seq
                .split_first()
                .expect("Couldn't get first str in seq when new a node");
            node.children.insert(first, TrieNode::new(first, rest));
        }
        node
    }

    fn add(&mut self, seq: &[&'a str]) {
        if seq.is_empty() {
            self.is_end = true;
        } else {
            let (first, rest) = seq
                .split_first()
                .expect("Couldn't get first str in seq when add seq");
            if let Some(child) = self.children.get_mut(first) {
                child.add(rest);
            } else {
                self.children.insert(first, TrieNode::new(first, rest));
            }
        }
    }

    pub(crate) fn find(&self, sentence: impl AsRef<str>) -> (String, bool) {
        let sentence = sentence.as_ref();
        let len = sentence.len();
        for i in 0..len {
            let j = len - i;
            if j <= len {
                let key = &sentence[0..j];
                if let Some(child) = self.children.get(key) {
                    let (buf, is_success) = child.find(&sentence[j..]);
                    if is_success {
                        // 目前特殊字符只有 g
                        if !buf.is_empty()
                            && let Some(ch) = buf.chars().last()
                            && self.is_special_char(ch)
                        {
                            // 看一下 buf 去掉特殊字符之后，是不是拼音
                            let (sub_buf, find_buf_child_is_success) =
                                child.find(&buf[0..buf.len() - 1]);
                            // 看一下特殊字符以及后面的字符能不能组成一个拼音
                            let special_key = &buf[buf.len() - 1..];
                            let (_, retry_find_child_is_success) =
                                if let Some(special_node) = self.children.get(special_key) {
                                    let new_sentence = &sentence[j + buf.len()..];
                                    special_node.find(new_sentence)
                                } else {
                                    ("".to_owned(), false)
                                };
                            if find_buf_child_is_success && retry_find_child_is_success {
                                return (format!("{key}{sub_buf}"), true);
                            }
                        }
                        return (format!("{key}{buf}"), true);
                    }
                }
            }
        }
        ("".to_owned(), self.is_end)
    }

    #[inline]
    fn is_special_char(&self, ch: char) -> bool {
        ch == 'g'
    }
}
